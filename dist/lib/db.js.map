{"version":3,"sources":["../../src/lib/db.ts","../../src/helpers/helpers.ts"],"sourcesContent":["import {\n  BlockObjectResponse,\n  ListBlockChildrenResponse,\n  QueryDatabaseParameters,\n  QueryDatabaseResponse,\n  RichTextItemResponse\n} from '@notionhq/client/build/src/api-endpoints'\nimport { get, set } from 'lodash'\nimport ogs from 'open-graph-scraper'\nimport { getPlaiceholder } from 'plaiceholder'\n\nimport { cleanText } from '../helpers/helpers'\nimport { BookmarkPreview, NotionSorts, Post } from '../interface'\nimport { notionMaxRequest } from './config'\n\n/**\n * We needs this method to be used in outside-nextjs environment. For example, in ./scripts/ud_images.ts\n *\n */\nexport async function getNotionDatabaseWithoutCache(\n  dataId: string,\n  notionToken: string,\n  notionVersion: string,\n  filter?: QueryDatabaseParameters['filter'],\n  startCursor?: string,\n  pageSize?: number,\n  sorts?: NotionSorts[]\n): Promise<QueryDatabaseResponse | undefined> {\n  try {\n    const url = `https://api.notion.com/v1/databases/${dataId}/query`\n    const requestBody = {\n      filter,\n      sorts,\n      start_cursor: startCursor,\n      page_size: pageSize\n    }\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${notionToken}`,\n        'Notion-Version': notionVersion as string,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody)\n    })\n    return res.json()\n  } catch (error: any) {\n    console.error(error)\n    // Retry after a number of seconds in the returned header\n    const retryAfter = error?.response?.headers['retry-after'] || error['retry-after']\n    if (retryAfter) {\n      console.log(`Retrying after ${retryAfter} seconds`)\n      await new Promise(resolve => setTimeout(resolve, retryAfter * 1000 + 500))\n      return await getNotionDatabaseWithoutCache(\n        dataId,\n        notionToken,\n        notionVersion,\n        filter,\n        startCursor,\n        pageSize,\n        sorts\n      )\n    }\n    return\n  }\n}\n\n/**\n * This methods will get all posts from a Notion database. Especially, when the number of posts is\n * greater than 100, we need to use the \"has_more\" and \"next_cursor\" to get all posts.\n *\n * TODO: Update the client's usage to use this method instead of getNotionDatabaseWithoutCache()\n */\nexport async function getPostsWithoutCache(options: {\n  dbId: string\n  notionToken: string\n  notionVersion: string\n  filter?: QueryDatabaseParameters['filter']\n  startCursor?: string\n  pageSize?: number\n  sorts?: NotionSorts[]\n}): Promise<any[]> {\n  const { dbId, notionToken, notionVersion, filter, startCursor, pageSize, sorts } = options\n\n  let data = await getNotionDatabaseWithoutCache(\n    dbId,\n    notionToken,\n    notionVersion,\n    filter,\n    startCursor,\n    pageSize,\n    sorts\n  )\n  let postsList = get(data, 'results', []) as any[]\n\n  if (data && data['has_more']) {\n    let newStartCursor = startCursor\n    while (data!['has_more']) {\n      newStartCursor = data!['next_cursor'] as string\n      data = await getNotionDatabaseWithoutCache(\n        dbId,\n        notionToken,\n        notionVersion,\n        filter,\n        startCursor,\n        pageSize,\n        sorts\n      )\n      if (get(data, 'results')) {\n        const lst = data!['results'] as any[]\n        postsList = [...postsList, ...lst]\n      }\n    }\n  }\n\n  return postsList\n}\n\n/**\n * We needs this method to be used in outside-nextjs environment. For example, in ./scripts/ud_images.ts\n */\nexport const getNotionPageWithoutCache = async (\n  pageId: string,\n  notionToken: string,\n  notionVersion: string\n) => {\n  const url = `https://api.notion.com/v1/pages/${pageId}`\n  const res = await fetch(url, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${notionToken}`,\n      'Notion-Version': notionVersion as string\n    }\n  })\n  return res.json()\n}\n\n/**\n * We needs this method to be used in outside-nextjs environment. For example, in ./scripts/ud_images.ts\n */\nexport const getNotionBlocksWithoutCache = async (\n  pageId: string,\n  notionToken: string,\n  notionVersion: string,\n  pageSize?: number,\n  startCursor?: string\n) => {\n  let url = `https://api.notion.com/v1/blocks/${pageId}/children`\n\n  if (pageSize) {\n    url += `?page_size=${pageSize}`\n    if (startCursor) url += `&start_cursor=${startCursor}`\n  } else if (startCursor) url += `?start_cursor=${startCursor}`\n\n  const res = await fetch(url, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${notionToken}`,\n      'Notion-Version': notionVersion as string\n    }\n  })\n  return res.json()\n}\n\n/**\n * https://developers.notion.com/reference/retrieve-a-database\n */\nexport async function retrieveNotionDatabaseWithoutCache(\n  dataId: string,\n  notionToken: string,\n  notionVersion: string\n) {\n  const url = `https://api.notion.com/v1/databases/${dataId}`\n  const res = await fetch(url, {\n    method: 'GET',\n    headers: {\n      Authorization: `Bearer ${notionToken}`,\n      'Notion-Version': notionVersion as string\n    }\n  })\n  return res.json()\n}\n\n/**\n * Get all nested blocks (in all levels) of a block.\n *\n */\nexport async function getBlocks(\n  blockId: string,\n  notionToken: string,\n  notionVersion: string,\n  initNumbering?: string,\n  getPageUri?: (pageId: string) => Promise<string | undefined>,\n  parseImgurUrl?: (url: string) => string\n): Promise<ListBlockChildrenResponse['results']> {\n  let data = await getNotionBlocksWithoutCache(blockId, notionToken, notionVersion)\n  let blocks = data?.results as\n    | (BlockObjectResponse & {\n        list_item?: string\n        children?: ListBlockChildrenResponse['results']\n        imageInfo?: any\n        imgUrl?: string\n        bookmark?: BookmarkPreview\n      })[]\n    | []\n\n  if (!blocks?.length) return []\n\n  if (data && data['has_more']) {\n    while (data!['has_more']) {\n      const startCursor = data!['next_cursor'] as string\n      data = await getNotionBlocksWithoutCache(\n        blockId,\n        notionToken,\n        notionVersion,\n        undefined,\n        startCursor\n      )\n      if (get(data, 'results') && get(data, 'results').length) {\n        const lst = data!['results'] as any[]\n        blocks = [...blocks, ...lst]\n      }\n    }\n  }\n\n  let number = 1\n  for (const block of blocks) {\n    /**\n     * Remark: Consider 2 cases:\n     * ++ First:\n     * 1. Item 1\n     * Paragraph\n     * 1. Item 2\n     *\n     * ++ Second:\n     * 1. Item 1\n     * 2. Item 2\n     *\n     * The Notion API doesn't give any information in that Item 1 and Item 2 of the first case are\n     * in diffrent uls while in the second case, they are in the same ul.\n     *\n     * They are both in the same structure.\n     * Check: https://developers.notion.com/reference/block#numbered-list-item-blocks\n     *\n     * That's why we add some additional information to the block.\n     */\n    if (block.type === 'numbered_list_item') {\n      if (initNumbering && ['1', '2', '3'].includes(initNumbering)) initNumbering = undefined\n      block['list_item'] = (initNumbering ?? '') + `${number}.`\n      number++\n    } else {\n      number = 1\n    }\n\n    if (block.type === 'bulleted_list_item') {\n      block['list_item'] = !initNumbering ? '1' : initNumbering === '1' ? '2' : '3'\n    }\n\n    if (get(block, `${block.type}.rich_text`) && !!getPageUri) {\n      const parsedMention = await parseMention(\n        get(block, `${block.type}.rich_text`) as RichTextItemResponse[],\n        getPageUri\n      )\n      set(block, `${block.type}.rich_text`, parsedMention)\n    }\n\n    if (block.has_children) {\n      const children = await getBlocks(\n        block.id,\n        notionToken,\n        notionVersion,\n        block['list_item'],\n        getPageUri,\n        parseImgurUrl\n      )\n      block['children'] = children\n    }\n\n    // Get real image size (width and height) of an image block\n    if (block.type === 'image') {\n      const url = get(block, 'image.file.url') || get(block, 'image.external.url')\n      if (url) {\n        // Resize the image to 1024x1024 max, except for gif and png (with transparent background)\n        if (parseImgurUrl) block['imgUrl'] = parseImgurUrl(url)\n        block['imageInfo'] = await getPlaceholderImage(url) // { base64, width, height }\n      }\n    }\n\n    // bookmark\n    if (block.type === 'bookmark') {\n      const url = get(block, 'bookmark.url')\n      if (url) {\n        const { result } = await ogs({ url })\n        const bookmark: BookmarkPreview = {\n          url,\n          title: cleanText(result.ogTitle),\n          description: cleanText(result.ogDescription) ?? null,\n          favicon: result.ogUrl + result.favicon.replace('/', ''),\n          imageSrc: result.ogImage?.[0]?.url ?? null\n        }\n        block['bookmark'] = bookmark as any\n      }\n    }\n  }\n\n  return blocks\n}\n\nasync function parseMention(\n  richText: RichTextItemResponse[] | [],\n  getPageUri?: (pageId: string) => Promise<string | undefined>\n): Promise<any> {\n  if (!richText?.length) return []\n  const newRichText = [] as RichTextItemResponse[]\n  for (const block of richText) {\n    if (block.type === 'mention' && block.mention?.type === 'page') {\n      const pageId = get(block, 'mention.page.id')\n      if (pageId) {\n        const pageUri = await getPageUri(pageId)\n        set(block, 'mention.page.uri', pageUri)\n      }\n      newRichText.push(block)\n    } else {\n      newRichText.push(block)\n    }\n  }\n  return newRichText\n}\n\n/**\n * Get blurDataURL (base64) of an image\n *\n * REMARK: This method MUST be placed in this file, otherwise, there will be an error of \"Can't resolve 'fs'\"\n */\nexport const getPlaceholderImage = async function getPlaceholderImage(src: string) {\n  const res = await fetch(src)\n  const arrayBuffer = await res.arrayBuffer()\n  if (arrayBuffer.byteLength === 0) return { base64: '', width: 0, height: 0 }\n  const buffer = await fetch(src).then(async res => Buffer.from(await res.arrayBuffer()))\n\n  const { base64, metadata } = await getPlaiceholder(buffer)\n  return { base64, width: metadata.width, height: metadata.height }\n}\n","import { Post } from '../interface'\n\nexport function cleanText(text?: string) {\n  if (!text) return undefined\n  return text.replace(/\\n/g, ' ').replace(/\\s+/g, ' ').trim()\n}\n\n/**\n * Convert \"7c2e54318e52416ca5769831454bf08d\" or \"7c2e5431-8e52-416c-a576-9831454bf08d\"\n * to \"7c2e5431-8e52-416c-a576-9831454bf08d\"\n */\nexport function idToUuid(id: string): string | null {\n  if (!id) {\n    return null\n  }\n\n  id = id.split('?')[0]\n  const match = id.match(/\\b([a-f0-9]{32})\\b/)\n\n  if (match) {\n    return `${id.slice(0, 8)}-${id.slice(8, 4 + 8)}-${id.slice(12, 4 + 12)}-${id.slice(\n      16,\n      4 + 16\n    )}-${id.slice(20)}`\n  }\n\n  const match2 = id.match(/\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/)\n  if (match2) {\n    return match2[1]\n  }\n\n  return null\n}\n\n/**\n * Convert \"Nguyễn Văn Đông\" to \"nguyen-van-dong\"\n */\nexport function makeSlugText(text?: string | null): string | undefined {\n  if (!text) return undefined\n  return text\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/đ/g, 'd')\n    .replace(/Đ/g, 'D')\n    .replace(':', '')\n    .split(' ')\n    .join('-')\n    .replace(/^\\/|\\/$/g, '') // remove \"/\" at the beginning and the end\n}\n\n/**\n * Get a right start_cursor for pagination based on current page and posts\n * @param posts\n * @param postsPerPage\n * @param currentPage\n * @returns next_cursor or `undefined` (it has to be `undefined`, not `null` because\n * Notion API doesn't accept `null` value for `start_cursor`)\n */\nexport function getStartCursorForCurrentPage(\n  currentPage: number,\n  posts: Post[],\n  postsPerPage: number\n): string | undefined {\n  if (posts?.length === 0) return undefined\n  if (currentPage === 1) return undefined\n  const numPages = Math.ceil(posts.length / postsPerPage)\n  if (currentPage > numPages) return undefined\n  return posts[(currentPage - 1) * postsPerPage]?.id\n}\n\nexport function isDateAfter(date1?: string, date2?: string): boolean {\n  if (!date1 || !date2) return false\n  const dateOne = new Date(date1).setHours(0,0,0,0)\n  const dateTwo = new Date(date2).setHours(0,0,0,0)\n  return dateOne > dateTwo\n}\n"],"mappings":";AAOA,SAAS,KAAK,WAAW;AACzB,OAAO,SAAS;AAChB,SAAS,uBAAuB;;;ACPzB,SAAS,UAAU,MAAe;AACvC,MAAI,CAAC;AAAM,WAAO;AAClB,SAAO,KAAK,QAAQ,OAAO,GAAG,EAAE,QAAQ,QAAQ,GAAG,EAAE,KAAK;AAC5D;;;ADcA,eAAsB,8BACpB,QACA,aACA,eACA,QACA,aACA,UACA,OAC4C;AAC5C,MAAI;AACF,UAAM,MAAM,uCAAuC,MAAM;AACzD,UAAM,cAAc;AAAA,MAClB;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,WAAW;AAAA,IACb;AACA,UAAM,MAAM,MAAM,MAAM,KAAK;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,eAAe,UAAU,WAAW;AAAA,QACpC,kBAAkB;AAAA,QAClB,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,KAAK,UAAU,WAAW;AAAA,IAClC,CAAC;AACD,WAAO,IAAI,KAAK;AAAA,EAClB,SAAS,OAAY;AACnB,YAAQ,MAAM,KAAK;AAEnB,UAAM,aAAa,OAAO,UAAU,QAAQ,aAAa,KAAK,MAAM,aAAa;AACjF,QAAI,YAAY;AACd,cAAQ,IAAI,kBAAkB,UAAU,UAAU;AAClD,YAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,aAAa,MAAO,GAAG,CAAC;AACzE,aAAO,MAAM;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA;AAAA,EACF;AACF;AAQA,eAAsB,qBAAqB,SAQxB;AACjB,QAAM,EAAE,MAAM,aAAa,eAAe,QAAQ,aAAa,UAAU,MAAM,IAAI;AAEnF,MAAI,OAAO,MAAM;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,YAAY,IAAI,MAAM,WAAW,CAAC,CAAC;AAEvC,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,QAAI,iBAAiB;AACrB,WAAO,KAAM,UAAU,GAAG;AACxB,uBAAiB,KAAM,aAAa;AACpC,aAAO,MAAM;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,IAAI,MAAM,SAAS,GAAG;AACxB,cAAM,MAAM,KAAM,SAAS;AAC3B,oBAAY,CAAC,GAAG,WAAW,GAAG,GAAG;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKO,IAAM,4BAA4B,OACvC,QACA,aACA,kBACG;AACH,QAAM,MAAM,mCAAmC,MAAM;AACrD,QAAM,MAAM,MAAM,MAAM,KAAK;AAAA,IAC3B,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,eAAe,UAAU,WAAW;AAAA,MACpC,kBAAkB;AAAA,IACpB;AAAA,EACF,CAAC;AACD,SAAO,IAAI,KAAK;AAClB;AAKO,IAAM,8BAA8B,OACzC,QACA,aACA,eACA,UACA,gBACG;AACH,MAAI,MAAM,oCAAoC,MAAM;AAEpD,MAAI,UAAU;AACZ,WAAO,cAAc,QAAQ;AAC7B,QAAI;AAAa,aAAO,iBAAiB,WAAW;AAAA,EACtD,WAAW;AAAa,WAAO,iBAAiB,WAAW;AAE3D,QAAM,MAAM,MAAM,MAAM,KAAK;AAAA,IAC3B,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,eAAe,UAAU,WAAW;AAAA,MACpC,kBAAkB;AAAA,IACpB;AAAA,EACF,CAAC;AACD,SAAO,IAAI,KAAK;AAClB;AAKA,eAAsB,mCACpB,QACA,aACA,eACA;AACA,QAAM,MAAM,uCAAuC,MAAM;AACzD,QAAM,MAAM,MAAM,MAAM,KAAK;AAAA,IAC3B,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,eAAe,UAAU,WAAW;AAAA,MACpC,kBAAkB;AAAA,IACpB;AAAA,EACF,CAAC;AACD,SAAO,IAAI,KAAK;AAClB;AAMA,eAAsB,UACpB,SACA,aACA,eACA,eACA,YACA,eAC+C;AAC/C,MAAI,OAAO,MAAM,4BAA4B,SAAS,aAAa,aAAa;AAChF,MAAI,SAAS,MAAM;AAUnB,MAAI,CAAC,QAAQ;AAAQ,WAAO,CAAC;AAE7B,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,WAAO,KAAM,UAAU,GAAG;AACxB,YAAM,cAAc,KAAM,aAAa;AACvC,aAAO,MAAM;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,IAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,EAAE,QAAQ;AACvD,cAAM,MAAM,KAAM,SAAS;AAC3B,iBAAS,CAAC,GAAG,QAAQ,GAAG,GAAG;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS;AACb,aAAW,SAAS,QAAQ;AAoB1B,QAAI,MAAM,SAAS,sBAAsB;AACvC,UAAI,iBAAiB,CAAC,KAAK,KAAK,GAAG,EAAE,SAAS,aAAa;AAAG,wBAAgB;AAC9E,YAAM,WAAW,KAAK,iBAAiB,MAAM,GAAG,MAAM;AACtD;AAAA,IACF,OAAO;AACL,eAAS;AAAA,IACX;AAEA,QAAI,MAAM,SAAS,sBAAsB;AACvC,YAAM,WAAW,IAAI,CAAC,gBAAgB,MAAM,kBAAkB,MAAM,MAAM;AAAA,IAC5E;AAEA,QAAI,IAAI,OAAO,GAAG,MAAM,IAAI,YAAY,KAAK,CAAC,CAAC,YAAY;AACzD,YAAM,gBAAgB,MAAM;AAAA,QAC1B,IAAI,OAAO,GAAG,MAAM,IAAI,YAAY;AAAA,QACpC;AAAA,MACF;AACA,UAAI,OAAO,GAAG,MAAM,IAAI,cAAc,aAAa;AAAA,IACrD;AAEA,QAAI,MAAM,cAAc;AACtB,YAAM,WAAW,MAAM;AAAA,QACrB,MAAM;AAAA,QACN;AAAA,QACA;AAAA,QACA,MAAM,WAAW;AAAA,QACjB;AAAA,QACA;AAAA,MACF;AACA,YAAM,UAAU,IAAI;AAAA,IACtB;AAGA,QAAI,MAAM,SAAS,SAAS;AAC1B,YAAM,MAAM,IAAI,OAAO,gBAAgB,KAAK,IAAI,OAAO,oBAAoB;AAC3E,UAAI,KAAK;AAEP,YAAI;AAAe,gBAAM,QAAQ,IAAI,cAAc,GAAG;AACtD,cAAM,WAAW,IAAI,MAAM,oBAAoB,GAAG;AAAA,MACpD;AAAA,IACF;AAGA,QAAI,MAAM,SAAS,YAAY;AAC7B,YAAM,MAAM,IAAI,OAAO,cAAc;AACrC,UAAI,KAAK;AACP,cAAM,EAAE,OAAO,IAAI,MAAM,IAAI,EAAE,IAAI,CAAC;AACpC,cAAM,WAA4B;AAAA,UAChC;AAAA,UACA,OAAO,UAAU,OAAO,OAAO;AAAA,UAC/B,aAAa,UAAU,OAAO,aAAa,KAAK;AAAA,UAChD,SAAS,OAAO,QAAQ,OAAO,QAAQ,QAAQ,KAAK,EAAE;AAAA,UACtD,UAAU,OAAO,UAAU,CAAC,GAAG,OAAO;AAAA,QACxC;AACA,cAAM,UAAU,IAAI;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,eAAe,aACb,UACA,YACc;AACd,MAAI,CAAC,UAAU;AAAQ,WAAO,CAAC;AAC/B,QAAM,cAAc,CAAC;AACrB,aAAW,SAAS,UAAU;AAC5B,QAAI,MAAM,SAAS,aAAa,MAAM,SAAS,SAAS,QAAQ;AAC9D,YAAM,SAAS,IAAI,OAAO,iBAAiB;AAC3C,UAAI,QAAQ;AACV,cAAM,UAAU,MAAM,WAAW,MAAM;AACvC,YAAI,OAAO,oBAAoB,OAAO;AAAA,MACxC;AACA,kBAAY,KAAK,KAAK;AAAA,IACxB,OAAO;AACL,kBAAY,KAAK,KAAK;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;AAOO,IAAM,sBAAsB,eAAeA,qBAAoB,KAAa;AACjF,QAAM,MAAM,MAAM,MAAM,GAAG;AAC3B,QAAM,cAAc,MAAM,IAAI,YAAY;AAC1C,MAAI,YAAY,eAAe;AAAG,WAAO,EAAE,QAAQ,IAAI,OAAO,GAAG,QAAQ,EAAE;AAC3E,QAAM,SAAS,MAAM,MAAM,GAAG,EAAE,KAAK,OAAMC,SAAO,OAAO,KAAK,MAAMA,KAAI,YAAY,CAAC,CAAC;AAEtF,QAAM,EAAE,QAAQ,SAAS,IAAI,MAAM,gBAAgB,MAAM;AACzD,SAAO,EAAE,QAAQ,OAAO,SAAS,OAAO,QAAQ,SAAS,OAAO;AAClE;","names":["getPlaceholderImage","res"]}